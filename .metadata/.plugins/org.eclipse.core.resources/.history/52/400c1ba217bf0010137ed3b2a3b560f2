#include "Dcm.h"
#include "stdint.h"
#include "stdbool.h"
#include "can.h"
#include <string.h>
#include <stdbool.h>

#define DCM_RESP_ID_DELTA 0x01u

typedef struct
{
	volatile uint8_t active;
	uint32_t fc_expect_id;
	volatile uint8_t fc_pending;
	uint8_t fc_bytes[8];
	uint8_t stmin_ms_default;
	uint32_t timeout_ms;
} iso_tx_ctx_t;

static iso_tx_ctx_t g =
{
		.active = 0, .fc_expect_id = 0, .fc_pending = 0,
		.stmin_ms_default = 0, .timeout_ms = 100
};
uint8_t rx[8];
volatile uint8_t Dcm_RequestPending;
volatile uint8_t Dcm_IsoTp_TxActive = 0u;
uint32_t Dcm_ActiveSessionState __attribute((section(".ncr")));
uint32_t Dcm_MainCounter = 0u;
uint32_t Dcm_TxMailbox = 0;
CAN_TxHeaderTypeDef Dcm_DiagTxHeader;
CAN_RxHeaderTypeDef Dcm_DiagRxHeader = {0, 0, 0, 0, 0, 0, 0};
uint8_t Dcm_RxData[8u];
uint8_t Dcm_TxData[8u];
uint8_t Dcm_SWV[4u] = {13u, 13u, 0xFFu, 0xFFu};
uint8_t Dcm_LoadStatus;
uint8_t Dcm_CC = 0u;
uint8_t Dcm_CDTCS = 0u;
uint32_t Dcm_SessionCounter = 1000u;
extern uint8_t SMon_CmdStat;
extern uint8_t SMon_RetryCnt;
extern uint8_t SMon_LockSupply;
extern uint32_t SMon_ISenseL1_RMS_5s;
extern uint32_t SMon_ISenseL1_RMS_10s;
extern uint32_t SMon_VfbT30_RMS_5s;
extern uint32_t SMon_VfbT30_RMS_10s;
extern uint32_t SMon_VfbL1_RMS_5s;
extern uint32_t SMon_VfbL1_RMS_10s;
extern uint32_t SMon_NTC_RMS_5s;
extern uint32_t SMon_NTC_RMS_10s;
extern uint32_t SMon_Vrefint_RMS_5s;
extern uint32_t SMon_Vrefint_RMS_10s;
extern uint32_t SMon_McuTemp_RMS_5s;
extern uint32_t SMon_McuTemp_RMS_10s;
extern uint32_t EcuM_TimeInSleep __attribute((section(".ncr")));
extern uint32_t EcuM_TimeActive __attribute((section(".ncr")));
extern uint32_t EcuM_TimeWithoutReset __attribute((section(".ncr")));
extern uint32_t EcuM_ResetCounter __attribute((section(".ncr")));
extern uint8_t EcuM_ResetReason __attribute((section(".ncr")));
extern uint8_t EcuM_ResetInfo __attribute((section(".ncr")));
extern float OS_XCP_CpuLoad;

bool Dcm_IsoTp_RxHook(const CAN_RxHeaderTypeDef *rh, const uint8_t *data);
bool Dcm_IsoTp_Send(uint32_t req_canid, const uint8_t *payload, uint16_t len, uint8_t pad, uint8_t force_pad);
void Dcm_IsoTp_Config(uint8_t stmin_default_ms, uint32_t timeout_ms);

void Dcm_TesterPresent();
void Dcm_ExtendedSession();
void Dcm_LoadControl();
void Dcm_main();
void Dcm_ProgrammingSession();
void Dcm_HardReset();
void Dcm_ReadSWV();
void Dcm_RC_HealSupply();
void Dcm_RC_ReadHistograms();
void Dcm_SendNrc();
void Dcm_RDBI_ResetCounter();
void Dcm_RDBI_TimeInSleep();
void Dcm_RDBI_TimeActive();
void Dcm_RDBI_TimeWithoutReset();
void Dcm_RDBI_ResetData();
void Dcm_RDBI_CpuLoad();
void Dcm_CommunicationControl();
void Dcm_ControlDTCSetting();
void Dcm_CDTCI();
void Dcm_RDTCI();
static HAL_StatusTypeDef Dcm_CanSendSF(uint32_t stdId,uint8_t *data,uint8_t len);
extern void EcuM_PerformReset(uint8_t reason, uint8_t info);

static HAL_StatusTypeDef Dcm_CanSendSF(uint32_t stdId,
		uint8_t *data,
		uint8_t len)
{
	CAN_TxHeaderTypeDef th = {0};
	uint32_t mbx;
	th.StdId = stdId;
	th.IDE   = CAN_ID_STD;
	th.RTR   = CAN_RTR_DATA;
	th.DLC   = len;

	HAL_StatusTypeDef st;
	do {
		st = HAL_CAN_AddTxMessage(&hcan, &th, data, &mbx);
	} while (st != HAL_OK);   // wait until a mailbox frees up

	return st;                  // HAL_OK or HAL_ERROR
}

void Dcm_CDTCI()
{
	// dummy todo

	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDTCI()
{
	// dummy todo
	uint8_t payload[7] = {
			0x59u,  /* Positive response to 0x19 */
			0x02u,  /* Subfunction echo: ReportDTCByStatusMask */
			0xFFu,  /* DTCStatusAvailabilityMask (for test: all bits supported) */
			0x31u,  /* DTC high byte: 0x31 */
			0x01u,  /* DTC middle byte: 0x01 */
			0x02u,  /* DTC low byte: 0x02 -> DTC 0x310102 */
			0x2Fu   /* statusOfDTC */
	};

	uint16_t len = 7u;
	(void)Dcm_IsoTp_Send(Dcm_DiagRxHeader.StdId, payload, len, 0x55u, 1u);

	for (uint8_t i = 0u; i < 8u; i++) {
		Dcm_TxData[i] = 0u;
		rx[i]        = 0u;
	}
}

void Dcm_CommunicationControl()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];

	Dcm_CC = rx[2u];

	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_ControlDTCSetting()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];

	Dcm_CDTCS = rx[2u];

	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDBI_CpuLoad()
{
	Dcm_TxData[0u] = rx[0u] + 1;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = (uint8_t)OS_XCP_CpuLoad;
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDBI_ResetData()
{
	Dcm_TxData[0u] = rx[0u] + 2;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = EcuM_ResetReason;
	Dcm_TxData[5u] = EcuM_ResetInfo;
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDBI_ResetCounter()
{
	Dcm_TxData[0u] = rx[0u] + 4;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = (uint8_t)(EcuM_ResetCounter);
	Dcm_TxData[5u] = (uint8_t)(EcuM_ResetCounter >> 8u);
	Dcm_TxData[6u] = (uint8_t)(EcuM_ResetCounter >> 16u);
	Dcm_TxData[7u] = (uint8_t)(EcuM_ResetCounter >> 24u);
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDBI_TimeInSleep()
{
	Dcm_TxData[0u] = rx[0u] + 4;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = (uint8_t)(EcuM_TimeInSleep);
	Dcm_TxData[5u] = (uint8_t)(EcuM_TimeInSleep >> 8u);
	Dcm_TxData[6u] = (uint8_t)(EcuM_TimeInSleep >> 16u);
	Dcm_TxData[7u] = (uint8_t)(EcuM_TimeInSleep >> 24u);
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDBI_TimeActive()
{
	Dcm_TxData[0u] = rx[0u] + 4;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = (uint8_t)(EcuM_TimeActive);
	Dcm_TxData[5u] = (uint8_t)(EcuM_TimeActive >> 8u);
	Dcm_TxData[6u] = (uint8_t)(EcuM_TimeActive >> 16u);
	Dcm_TxData[7u] = (uint8_t)(EcuM_TimeActive >> 24u);
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RDBI_TimeWithoutReset()
{
	Dcm_TxData[0u] = rx[0u] + 4;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = (uint8_t)(EcuM_TimeWithoutReset);
	Dcm_TxData[5u] = (uint8_t)(EcuM_TimeWithoutReset >> 8u);
	Dcm_TxData[6u] = (uint8_t)(EcuM_TimeWithoutReset >> 16u);
	Dcm_TxData[7u] = (uint8_t)(EcuM_TimeWithoutReset >> 24u);
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_TesterPresent()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_ExtendedSession()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_ActiveSessionState = rx[2u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_LoadControl()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_LoadStatus = rx[5u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

static inline void le32(uint8_t *p, uint32_t v)
{
	p[0]=(uint8_t)v; p[1]=(uint8_t)(v>>8); p[2]=(uint8_t)(v>>16); p[3]=(uint8_t)(v>>24);
}

static uint16_t Dcm_BuildHist_RC(uint8_t *out)
{
	out[0] = 0x71;
	out[1] = rx[2];      /* subfunction echo */
	out[2] = rx[3];      /* routineId high */
	out[3] = rx[4];      /* routineId low */
	uint8_t *p = &out[4];
	le32(p, SMon_ISenseL1_RMS_5s);   p+=4;
	le32(p, SMon_ISenseL1_RMS_10s);  p+=4;
	le32(p, SMon_VfbT30_RMS_5s);     p+=4;
	le32(p, SMon_VfbT30_RMS_10s);    p+=4;
	le32(p, SMon_VfbL1_RMS_5s);      p+=4;
	le32(p, SMon_VfbL1_RMS_10s);     p+=4;
	le32(p, SMon_NTC_RMS_5s);      p+=4;
	le32(p, SMon_NTC_RMS_10s);     p+=4;
	le32(p, SMon_Vrefint_RMS_5s);      p+=4;
	le32(p, SMon_Vrefint_RMS_10s);     p+=4;
	le32(p, SMon_McuTemp_RMS_5s);      p+=4;
	le32(p, SMon_McuTemp_RMS_10s);     p+=4;
	return (uint16_t)(p - out);
}

void Dcm_IsoTp_Config(uint8_t stmin_default_ms, uint32_t timeout_ms)
{
	g.stmin_ms_default = stmin_default_ms;
	g.timeout_ms = timeout_ms;
}

bool Dcm_IsoTp_RxHook(const CAN_RxHeaderTypeDef *rh, const uint8_t *d)
{
	if (!g.active) return false;
	if (rh->IDE != CAN_ID_STD) return false;
	if (rh->StdId != g.fc_expect_id) return false;
	if ( (d[0] & 0xF0u) != 0x30u ) return false; /* not FC */
	if (!g.fc_pending) {
		memcpy((void*)g.fc_bytes, d, 8u);
		g.fc_pending = 1;
	}
	return true; /* consumed by ISO-TP */
}

static HAL_StatusTypeDef can_tx8(uint32_t stdId, const uint8_t *data, uint8_t len,
		uint8_t pad, uint8_t force_pad)
{
	CAN_TxHeaderTypeDef th = {0};
	uint32_t mbx;
	th.StdId = stdId;
	th.IDE   = CAN_ID_STD;
	th.RTR   = CAN_RTR_DATA;

	uint8_t buf[8];
	const uint8_t *p;

	if (force_pad) {
		memset(buf, pad, 8);
		memcpy(buf, data, len);
		th.DLC = 8;
		p = buf;
	} else {
		th.DLC = len;
		p = data;
	}

	HAL_StatusTypeDef st;
	do {
		st = HAL_CAN_AddTxMessage(&hcan, &th, (uint8_t*)p, &mbx);
	} while (st != HAL_OK);  /* wait until mailbox frees up */

	return st;  /* HAL_OK or HAL_ERROR */
}


static int wait_fc(uint8_t *bs, uint8_t *stmin_ms)
{
	uint32_t t0 = HAL_GetTick();
	while ((HAL_GetTick() - t0) < g.timeout_ms) {
		if (g.fc_pending) {
			g.fc_pending = 0;
			const uint8_t *rx = g.fc_bytes;
			uint8_t fs = rx[0] & 0x0Fu;
			if (fs == 0x00u) { /* CTS */
				*bs = rx[1];
				uint8_t st = rx[2];
				if (st <= 0x7Fu) *stmin_ms = st;
				else if (st >= 0xF1u && st <= 0xF9u) *stmin_ms = 1; /* 100..900us -> round up to 1 ms */
				else *stmin_ms = g.stmin_ms_default;
				return 1;
			} else if (fs == 0x01u) { /* Wait */
				t0 = HAL_GetTick();
			} else { /* Overflow/Abort */
				return -1;
			}
		}
	}
	return 0; /* timeout */
}

bool Dcm_IsoTp_Send(uint32_t req_canid, const uint8_t *payload, uint16_t len,
		uint8_t pad, uint8_t force_pad)
{
	uint32_t resp_id = req_canid + DCM_RESP_ID_DELTA;
	uint8_t f[8];

	Dcm_IsoTp_TxActive = 1u;   /* block normal CAN TX while we stream */

	if (len <= 7u) {
		f[0] = (uint8_t)(0x00u | (len & 0x0Fu));
		memcpy(&f[1], payload, len);
		bool ok = (can_tx8(resp_id, f, (uint8_t)(1u + len), pad, force_pad) == HAL_OK);
		Dcm_IsoTp_TxActive = 0u;
		return ok;
	}

	/* First Frame */
	f[0] = (uint8_t)(0x10u | ((len >> 8) & 0x0Fu));
	f[1] = (uint8_t)(len & 0xFFu);
	memcpy(&f[2], payload, 6u);
	g.active = 1;
	g.fc_expect_id = req_canid;
	g.fc_pending = 0;

	if (can_tx8(resp_id, f, 8u, pad, force_pad) != HAL_OK) {
		g.active = 0;
		Dcm_IsoTp_TxActive = 0u;
		return false;
	}

	uint8_t bs = 0, stmin = g.stmin_ms_default;
	int fc = wait_fc(&bs, &stmin);
	if (fc <= 0) {
		g.active = 0;
		Dcm_IsoTp_TxActive = 0u;
		return false;
	}

	uint16_t idx = 6u;
	uint8_t  sn  = 1u;
	uint8_t  bs_cnt = bs;

	while (idx < len) {
		if (bs != 0u && bs_cnt == 0u) {
			fc = wait_fc(&bs, &stmin);
			if (fc <= 0) {
				g.active = 0;
				Dcm_IsoTp_TxActive = 0u;
				return false;
			}
			bs_cnt = bs;
		}

		f[0] = (uint8_t)(0x20u | (sn & 0x0Fu));
		uint8_t chunk = (uint8_t)((len - idx) >= 7u ? 7u : (len - idx));
		memset(&f[1], pad, 7u);
		memcpy(&f[1], &payload[idx], chunk);

		if (can_tx8(resp_id, f, (uint8_t)(1u + chunk), pad, force_pad) != HAL_OK) {
			g.active = 0;
			Dcm_IsoTp_TxActive = 0u;
			return false;
		}

		idx += chunk;
		sn = (uint8_t)((sn + 1u) & 0x0Fu);
		if (bs != 0u && bs_cnt > 0u) bs_cnt--;
		if (stmin) HAL_Delay(stmin);
	}

	g.active = 0;
	Dcm_IsoTp_TxActive = 0u;
	return true;
}


void Dcm_RC_ReadHistograms()
{
	uint8_t payload[4+72];
	uint16_t len = Dcm_BuildHist_RC(payload);
	(void)Dcm_IsoTp_Send(Dcm_DiagRxHeader.StdId, payload, len, 0x55u, 1u);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_ProgrammingSession()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_ActiveSessionState = rx[2u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	HAL_Delay(1);
	EcuM_PerformReset(0u, 0u);
}

void Dcm_SendNrc()
{
	Dcm_TxData[0u] = 0x03;
	Dcm_TxData[1u] = 0x7f;
	Dcm_TxData[2u] = 0x19;
	Dcm_TxData[3u] = 0x22;
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_HardReset()
{
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	HAL_Delay(1);
	EcuM_PerformReset(0u, 0u);
}

void Dcm_ReadSWV()
{
	Dcm_TxData[0u] = rx[0u] + 4u;
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = Dcm_SWV[0u];
	Dcm_TxData[5u] = Dcm_SWV[1u];
	Dcm_TxData[6u] = Dcm_SWV[2u];
	Dcm_TxData[7u] = Dcm_SWV[3u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	Dcm_DiagTxHeader.DLC = 0;
	Dcm_DiagTxHeader.StdId = 0;
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
}

void Dcm_RC_HealSupply()
{
	SMon_RetryCnt = 0u;
	SMon_LockSupply = 0u;
	Dcm_TxData[0u] = rx[0u];
	Dcm_TxData[1u] = rx[1u] + 0x40u;
	Dcm_TxData[2u] = rx[2u];
	Dcm_TxData[3u] = rx[3u];
	Dcm_TxData[4u] = rx[4u];
	Dcm_TxData[5u] = rx[5u];
	Dcm_TxData[6u] = rx[6u];
	Dcm_TxData[7u] = rx[7u];
	Dcm_DiagTxHeader.DLC = Dcm_DiagRxHeader.DLC;
	Dcm_DiagTxHeader.StdId = Dcm_DiagRxHeader.StdId + 0x01u;
	(void)Dcm_CanSendSF(Dcm_DiagRxHeader.StdId + 0x01u, Dcm_TxData, Dcm_DiagTxHeader.DLC);
	for(uint8_t i = 0u; i < 8u; i++)
	{
		Dcm_TxData[i] = 0u;
		rx[i] = 0u;
	}
	Dcm_DiagTxHeader.DLC = 0;
	Dcm_DiagTxHeader.StdId = 0;
}

void Dcm_main()
{
	/* Atomic snapshot of pending request */
	__disable_irq();
	if (Dcm_RequestPending)
	{
		for (uint8_t i = 0u; i < 8u; i++)
		{
			rx[i] = Dcm_RxData[i];
			Dcm_RxData[i] = 0u;
		}

		Dcm_RequestPending = 0u;
		Dcm_SessionCounter = 1000u;
	}
	else
	{
		if(0u != Dcm_SessionCounter)
		{
			Dcm_SessionCounter --;
		}
		else
		{
			/* Do nothing. */
		}

	}
	__enable_irq();

	if(0u == Dcm_MainCounter)
	{
		Dcm_ActiveSessionState = 0u;
		Dcm_IsoTp_Config(/*stmin_default_ms=*/50u, /*timeout_ms=*/5000u);
	}
	else
	{
		/* Do nothing. */
	}

	if(0u == Dcm_SessionCounter)
	{
		Dcm_ActiveSessionState = 0u;
	}
	else
	{
		/* Do nothing. */
	}

	if(0x14u == rx[1u])
	{
		Dcm_CDTCI();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x19u == rx[1u])
	{
		Dcm_RDTCI();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x28u == rx[1u] && 3u == Dcm_ActiveSessionState)
	{
		Dcm_CommunicationControl();
	}
	else if(0x28u == rx[1u] && 3u != Dcm_ActiveSessionState)
	{
		Dcm_SendNrc();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x85u == rx[1u] && 3u == Dcm_ActiveSessionState)
	{
		Dcm_ControlDTCSetting();
	}
	else if(0x85u == rx[1u] && 3u != Dcm_ActiveSessionState)
	{
		Dcm_SendNrc();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x22u == rx[1u])
	{
		switch(rx[3u])
		{
		case 0x01u:
			Dcm_RDBI_ResetCounter();
			break;
		case 0x02u:
			Dcm_RDBI_TimeInSleep();
			break;
		case 0x03u:
			Dcm_RDBI_TimeActive();
			break;
		case 0x04u:
			Dcm_RDBI_TimeWithoutReset();
			break;
		case 0x05u:
			Dcm_RDBI_ResetData();
			break;
		case 0x06u:
			Dcm_RDBI_CpuLoad();
			break;
		case 0x80u:
			Dcm_ReadSWV();
			break;
		default:
			Dcm_SendNrc();
			break;
		}
	}
	else
	{
		/* Do nothing. */
	}

	if(0x02 == rx[2u] && (0u == SMon_CmdStat && 0u == Dcm_LoadStatus) && 3u == Dcm_ActiveSessionState)
	{
		Dcm_ProgrammingSession();
	}
	else if(0x02 == rx[2u] && (1u == SMon_CmdStat || 1u == Dcm_LoadStatus))
	{
		Dcm_SendNrc();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x11u == rx[1u] && 0x01u == rx[2u] && (0u == SMon_CmdStat && 0u == Dcm_LoadStatus))
	{
		Dcm_HardReset();
	}
	else if(0x11u == rx[1u] && 0x01u == rx[2u] && (1u == SMon_CmdStat || 1u == Dcm_LoadStatus))
	{
		Dcm_SendNrc();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x40u == rx[4u] && 0x31u == rx[1u])
	{
		Dcm_RC_HealSupply();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x42u == rx[4u] && 0x31u == rx[1u] && 3u == Dcm_ActiveSessionState)
	{
		Dcm_LoadControl();
	}
	else if(0x42u == rx[4u] && 0x31u == rx[1u] && 3u != Dcm_ActiveSessionState)
	{
		Dcm_SendNrc();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x41u == rx[4u] && 0x31u == rx[1u] && 3u == Dcm_ActiveSessionState)
	{
		Dcm_RC_ReadHistograms();
	}
	else if(0x41u == rx[4u] && 0x31u == rx[1u] && 3u != Dcm_ActiveSessionState)
	{
		Dcm_SendNrc();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x10u == rx[1u] && 0x03u == rx[2u])
	{
		Dcm_ExtendedSession();
	}
	else
	{
		/* Do nothing. */
	}

	if(0x3E == rx[1u] && 0x80u == rx[2u])
	{
		Dcm_TesterPresent();
	}
	else
	{
		/* Do nothing. */
	}

	Dcm_MainCounter++;
}
